Index: app/src/main/java/com/example/app/ui/home/HomeViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.app.ui.home\r\n\r\nimport android.util.Log\r\nimport androidx.lifecycle.LiveData\r\nimport androidx.lifecycle.MutableLiveData\r\nimport androidx.lifecycle.ViewModel\r\nimport com.google.firebase.auth.FirebaseAuth\r\nimport com.google.firebase.firestore.DocumentReference\r\nimport com.google.firebase.firestore.DocumentSnapshot\r\nimport com.google.firebase.firestore.QuerySnapshot\r\nimport com.google.firebase.firestore.ktx.firestore\r\nimport com.google.firebase.ktx.Firebase\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.tasks.await\r\nimport kotlinx.coroutines.withContext\r\n\r\nclass HomeViewModel : ViewModel() {\r\n\r\n    private val db = Firebase.firestore\r\n\r\n    val ref = db.collection(\"alimentos\")\r\n\r\n    private val _ingredientList = MutableLiveData<List<IngredientModel>>()\r\n\r\n    private val auth = FirebaseAuth.getInstance()\r\n    val ref2 = db.collection(\"menu_dia\").document(auth.currentUser?.uid.toString())\r\n    private lateinit var reference: DocumentReference\r\n\r\n    private val _userEmail = MutableLiveData<String>().apply {\r\n        value = auth.currentUser?.email\r\n    }\r\n    private val _userName = MutableLiveData<String>().apply {\r\n        value = auth.currentUser?.displayName\r\n    }\r\n\r\n    val userEmail: LiveData<String> = _userEmail\r\n    val userName: LiveData<String> = _userName\r\n\r\n\r\n    suspend fun getData2() {\r\n\r\n        Log.d(\"comprobar\", \"referencia->${ref2}\")\r\n\r\n\r\n        return withContext(Dispatchers.IO) {\r\n            val document: DocumentSnapshot = ref2.get().await()\r\n            if (document.exists()) {\r\n                Log.d(\"comprobar\", \"referenciaDocument->${document.data?.get(\"menu1\")}\")\r\n\r\n            }\r\n        }\r\n    }\r\n    fun getData3() {\r\n\r\n        Log.d(\"comprobar\", \"referencia->${ref2}\")\r\n        Log.d(\"comprobar\", \"uid->${auth.currentUser?.uid.toString()}\")\r\n        ref2.get()\r\n            .addOnSuccessListener { document ->\r\n                if (document != null) {\r\n                    Log.d(\"comprobar\", \"DocumentSnapshot data: ${document.data?.get(\"menu1\")}\")\r\n                    reference= document.data?.get(\"menu1\") as DocumentReference\r\n                    reference.get()\r\n                        .addOnSuccessListener { document2 ->\r\n                            if (document2 != null) {\r\n                                Log.d(\"comprobar\", \"DocumentSnapshot data: ${document2.data}\")\r\n\r\n                            } else {\r\n                                Log.d(\"comprobar\", \"No such document\")\r\n                            }\r\n                        }\r\n                        .addOnFailureListener { exception ->\r\n                            Log.d(\"comprobar\", \"get failed with \", exception)\r\n                        }\r\n                } else {\r\n                    Log.d(\"comprobar\", \"No such document\")\r\n                }\r\n            }\r\n            .addOnFailureListener { exception ->\r\n                Log.d(\"comprobar\", \"get failed with \", exception)\r\n            }\r\n\r\n\r\n    }\r\n\r\n\r\n    //Creo una funcion en suspend, para que se ejecute en segundo plano\r\n    suspend fun getData(): List<IngredientModel>? {\r\n        //El withContext se utiliza para cambiar de contexto, es decir, para permitir que se realice en segundo plano desde otra clas\r\n        //El dispatcher sirve para que cuando se termine de realizar en este caso la recogida de datos, toma control sobre la ejecucion para realizar\r\n        //un cambio\r\n        return withContext(Dispatchers.IO) {\r\n            try {\r\n                //EL QuerySnapshot contiene el result de la query\r\n                //Le ponemos como await para congelar la funcion hasta que la llamada haya terminado, es decir para esperar a que se recojan todos los datos\r\n                val result: QuerySnapshot = ref.get().await()\r\n                val ingredients = mutableListOf<IngredientModel>()\r\n                //Recorremos el result para obtener todos los elementos\r\n                for (document in result.documents) {\r\n                    val name = document[\"nombre\"].toString()\r\n                    val proteinas = document[\"proteinas\"].toString()\r\n                    val grasas = document[\"grasas\"].toString()\r\n                    val hidratos_de_carbono = document[\"hidratos_de_carbono\"].toString()\r\n                    val calorias = document[\"calorias\"].toString()\r\n                    val imagen = document[\"imagen\"].toString()\r\n\r\n                    val ingredient = IngredientModel(\r\n                        name,\r\n                        proteinas,\r\n                        grasas,\r\n                        hidratos_de_carbono,\r\n                        calorias,\r\n                        imagen\r\n                    )\r\n                    ingredients.add(ingredient)\r\n                }\r\n                _ingredientList.postValue(ingredients)\r\n\r\n                //Este @withContext, simplemente es para que sea mas claro de que metododo es este return,\r\n                //en este caso de return withContext(Dispatchers.IO) de arriba\r\n                return@withContext ingredients\r\n            } catch (e: Exception) {\r\n                Log.e(\"Comprobar\", \"Error getting data: ${e.message}\")\r\n                return@withContext null\r\n            }\r\n        }\r\n    }\r\n\r\n    fun logOut() {\r\n        auth.signOut()\r\n    }\r\n\r\n    /*fun getData(): List<IngredientModel>? {\r\n        //val document = Firebase.firestore.collection(\"alimentos\").get().await()\r\n\r\n        ref.get().addOnCompleteListener { result ->\r\n            val resulSet = result.result\r\n            val ingredients = mutableListOf<IngredientModel>()\r\n\r\n            for (nombre in resulSet!!) {\r\n                val name = nombre[\"nombre\"].toString()\r\n                val proteinas = nombre[\"proteinas\"].toString()\r\n                val grasas = nombre[\"grasas\"].toString()\r\n                val hidratos_de_carbono = nombre[\"hidratos_de_carbono\"].toString()\r\n                val calorias = nombre[\"calorias\"].toString()\r\n                val imagen = nombre[\"imagen\"].toString()\r\n                val ingredient = IngredientModel(name, proteinas, grasas, hidratos_de_carbono, calorias, imagen)\r\n                ingredients.add(ingredient)\r\n            }\r\n            _ingredientList.value = ingredients\r\n        }\r\n        Log.d(\"Comprobar\", \"HomeViewModel -> ingredients list ${_ingredientList.value}\")\r\n        return _ingredientList.value\r\n    }*/\r\n    /* companion object {\r\n         val isReady: Boolean = true\r\n     }*/\r\n}
===================================================================
diff --git a/app/src/main/java/com/example/app/ui/home/HomeViewModel.kt b/app/src/main/java/com/example/app/ui/home/HomeViewModel.kt
--- a/app/src/main/java/com/example/app/ui/home/HomeViewModel.kt	
+++ b/app/src/main/java/com/example/app/ui/home/HomeViewModel.kt	
@@ -104,7 +104,7 @@
                     val imagen = document["imagen"].toString()
 
                     val ingredient = IngredientModel(
-                        name,
+                        document["nombre"].toString(),
                         proteinas,
                         grasas,
                         hidratos_de_carbono,
